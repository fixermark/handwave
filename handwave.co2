;; -*- mode: scheme; -*-

(do

 (nes-header #:num-prg 1 #:num-chr 1 #:mapper 0 #:mirroring vertical)

 ;; memory mapping
 (defaddr sprite-data #x200) ;; where the sprite control data is
 (defconst sprite-dma 2) ;; dma address is 100X this = $200
 (defaddr pad-data #x300) ;; pad data for controllers 1 to 4, 4 bytes
 (defaddr pad-data-last-frame #x304)  ;; pad data from last frame, 4 bytes
 (defaddr pad-press #x308)  ;; which buttons were pressed this frame, 4 bytes
 (defaddr notes-to-sound #x30c)  ;; notes to start sounding this frame, 2 bytes
 (defaddr sprite-pos-x #x30e) ;; current sprite position (x coord), 16 bytes
 (defaddr sprite-pos-y #x31e)  ;; current sprite position (y coord), 16 bytes
 (defaddr sprite-anim-frame #x32e)  ;; sprite animation frame counter, 16 bytes

 (defconst ppu-name-table-0 #x2000)
 (defconst ppu-palette #x3f00)


 ;; CHRs used by sprites
 (defconst left-arrow-chr 1)
 (defconst right-arrow-chr 2)
 (defconst b-button-chr 3)
 (defconst a-button-chr 4)

 ;; sprite rendering constants
 (defconst num-sprites 16)
 (defconst num-waves 16)
 (defconst ANIM-STOPPED #xFF)
 (defconst sprite-x-offset 40)
 (defconst first-sprite-y-offset 40)

 ;; control pad button masks in pad-data
 (defconst joypad-a      #b10000000)
 (defconst joypad-b      #b01000000)
 (defconst joypad-select #b00100000)
 (defconst joypad-start  #b00010000)
 (defconst joypad-up     #b00001000)
 (defconst joypad-down   #b00000100)
 (defconst joypad-left   #b00000010)
 (defconst joypad-right  #b00000001)

 ;; code start
 (program-begin #xc000)

 ;; a global frame counter
 (defvar gframe 0)

 (defvector (reset)
   (init-system)
   ;; disable all graphics.
   (set! REG-PPU-CTRL 0)
   (set! REG-PPU-MASK 0)
   ;; init graphics
   (init-graphics)
   ;; set basic ppu registers.  load background from $0000,
   ;; sprites from $0000, and the name table from $2000.
   (set! REG-PPU-CTRL #b10000000)
   (set! REG-PPU-MASK #b00011110)
   ;; enable audio tools for system
   (set! REG-APU-CHANNEL #b00000111)
   (asm
    ;; go into an infite loop - vblank interrupt takes over
    "loop: jmp loop"))

 (defsub (init-graphics)
   (load-bg #x00)
   (load-palette)
   (init-sprites))

 (defsub (load-bg chr-code)
   (loop n 0 3
	 (ppu-memset ppu-name-table-0 n 0 128 chr-code)
	 (ppu-memset ppu-name-table-0 n #x80 128 chr-code))
   (ppu-memset ppu-name-table-0 3 0 128 chr-code)
   (ppu-memset ppu-name-table-0 3 #x80 (- #xC0 #x80) chr-code)
   )

 (defsub (load-palette)
   (ppu-memcpy ppu-palette 0 0 #x20 palette 0))

 (defsub (init-sprites)
   (loop n 0 num-sprites
	 (set-sprite-x! n sprite-x-offset)
	 (set-sprite-y! n (+ first-sprite-y-offset (<< n 3)))
	 ;; sprite ID rotates 1 to 4
	 (set-sprite-id! n (+ 1 (and n #x03)))
	 ;; every 4 sprites get same palette
	 (set-sprite-attr! n (>> n 2))
	 (poke! sprite-pos-x n sprite-x-offset)
	 (poke! sprite-pos-y n (+ first-sprite-y-offset (<< n 3)))
	 (poke! sprite-anim-frame n ANIM-STOPPED)))

 (defvector (nmi)
   ;; start sprite data dma to the oam
   (set! REG-OAM-DMA sprite-dma)
   (set! REG-PPU-SCROLL 0)
   (set! REG-PPU-SCROLL 0)
   (inc gframe)

   (read-joypads)
   (check-wave-activations)
   (sound-notes)
   (anim-sprites))

 ;;;; GAME LOGIC
 ;; check controller inputs for wave activations
 (defsub (check-wave-activations)
   (let ((offset1) (offset2))
     (loop n 0 num-waves
	   (set! offset1 (<< n 1))
	   (set! offset2 (+ 1 offset1))
	 (if (button-pressed (peek controller-mapping offset1) (peek controller-mapping offset2))
	     (on-wave-triggered n)
	     #f))))

 (defsub (on-wave-triggered which-wave)
   (poke! sprite-anim-frame which-wave 0)
   (sound-note which-wave))

 ;; primes a note to be sounded this cycle
 (defsub (sound-note which-note)
   (let ((bank))
     (if (> which-note 7)
	 (do
	     (set! bank 1)
	     (set! which-note (- which-note 8)))
	 (set! bank 0))
     (poke! notes-to-sound bank (or (peek notes-to-sound bank) (roll-left-n #x1 which-note)))))

 ;; utility function to roll a value n to the left
 (defsub (roll-left-n value count)
   ; surprisingly, this seems necessary to catch 0 counts
   (if (eq? count 0)
       (return value)
       #f)
   (loop n 0 count
	 (set! value (<< value 1)))
   (return value))

 ;;;; CONTROLLER LOGIC
 ;; read in joypad input
 (defsub (read-joypads)
     ;; request data from joypads
     (set! REG-JOYPAD-0 1)
     (set! REG-JOYPAD-0 0)
     (read-joypad-0 0)
     (read-joypad-0 2)
     (loop n 0 8
     	   (peek REG-JOYPAD-0))
     (set! REG-JOYPAD-1 1)
     (set! REG-JOYPAD-1 0)
     (read-joypad-1 1)
     (read-joypad-1 3)
     (loop n 0 8
     	   (peek REG-JOYPAD-1))
     (update-pad-presses))

 ;; read input from joy port 0
 ;; TODO: should be able to use macros or pass an address arg to consolidate this with read-joypad-1
 (defsub (read-joypad-0 store-offset)
   (let ((pad))
     (set! pad 0)
     (loop n 0 8
	   (set! pad (<< pad 1))
	   (set! pad (or pad (and (peek REG-JOYPAD-0 0) #x1))))
     (poke! pad-data store-offset pad)))

 ;; read input from joy port 1
 ;; TODO: should be able to use macros or pass an address arg to consolidate this with read-joypad-0
 (defsub (read-joypad-1 store-offset)
   (let ((pad))
     (set! pad 0)
     (loop n 0 8
	   (set! pad (<< pad 1))
	   (set! pad (or pad (and (peek REG-JOYPAD-1 0) #x1))))
     (poke! pad-data store-offset pad)))



 ;; update last frame and pad presses
 (defsub (update-pad-presses)
   (let ((rising-edge))
   (loop n 0 4
	 (set! rising-edge (xor (peek pad-data-last-frame n) #xff))
	 (poke! pad-press n (and (peek pad-data n) rising-edge))
	 (poke! pad-data-last-frame n (peek pad-data n)))))


 ;; check to see if button on controller was pressed
 (defsub (button-pressed which-controller which-button)
   (return (and (peek pad-press which-controller) which-button)))

 ;;;; GRAPHICS ROUTINES

 ;; animation update for sprites
 (defsub (anim-sprites)
   (let ((cur-x) (cur-y) (cur-anim-frame) (tmp))
     (loop n 0 num-sprites
	   (set! cur-x (peek sprite-pos-x n))
	   (set! cur-y (peek sprite-pos-y n))
	   (set! cur-anim-frame (peek sprite-anim-frame n))
	   (if (not (eq? cur-anim-frame ANIM-STOPPED))
	       (do
		   (set-multiple! cur-x cur-y (calculate-sprite-offset cur-x cur-y cur-anim-frame))
		   (update-anim-frame n cur-anim-frame))
	       #f)
	   (set-sprite-x! n cur-x)
	   (set-sprite-y! n cur-y))))

 (defsub (calculate-sprite-offset cur-x cur-y cur-anim-frame)
   (let ((tmp))
   (set! cur-x (+ cur-x (peek animations (<< cur-anim-frame 1))))
   ;; this shouldn't be necessary, but it appears (+ 1 a) freaks out if a is a left-shift expression
   (set! tmp (<< cur-anim-frame 1))
   (set! cur-y (+ cur-y (peek animations (+ 1 tmp))))
   (return cur-x cur-y)))

 (defsub (update-anim-frame sprite-idx cur-anim-frame)
   (inc cur-anim-frame)
   (if (eq? (peek animations (<< cur-anim-frame 1)) #x80)
       (set! cur-anim-frame ANIM-STOPPED) #f)
   (poke! sprite-anim-frame sprite-idx cur-anim-frame))

 ;;;; AUDIO ROUTINES


 (defsub (sound-notes)
   ;; finish later
   (if (peek notes-to-sound 0)
       (do
	   (set! REG-APU-PULSE1-CONTROL #b10000011)
	   (set! REG-APU-PULSE1-RAMP #b00000000)
	   (set! REG-APU-PULSE1-FT #x0c)
	 (set! REG-APU-PULSE1-CT #b11111011))
       #f)
   (if (peek notes-to-sound 1)
       (do
	   (set! REG-APU-PULSE2-CONTROL #b10000011)
	   (set! REG-APU-PULSE1-RAMP #b00000000)
	   (set! REG-APU-PULSE2-FT #xc9)
	 (set! REG-APU-PULSE2-CT (or (<< #b00011111 3) #x01)))
       #f)
   (poke! notes-to-sound 0 0)
   (poke! notes-to-sound 1 0)
   )

 ;;;; DATA SECTION

 ;; mapping from buttons to waves
 ;; mapping is pairs of the form controller-id, which-button
 (deflabel controller-mapping)
 (bytes
  0 joypad-left
  0 joypad-right
  0 joypad-b
  0 joypad-a
  1 joypad-left
  1 joypad-right
  1 joypad-b
  1 joypad-a
  2 joypad-left
  2 joypad-right
  2 joypad-b
  2 joypad-a
  3 joypad-left
  3 joypad-right
  3 joypad-b
  3 joypad-a)


 ;; Main palette
 (deflabel palette)
 (bytes
  #x0f ; background color
  #x20 #x11 #x14  ; bg palette 1
  #x0f
  #x01 #x11 #x12  ; bg palette 2
  #x0f
  #x11 #x22 #x31  ; bg palette 3
  #x0f
  #x20 #x27 #xcc  ; bg palette 4

  #x0F
  #x20 #x15 #x14  ; fg palette 1 (player 1)
  #x0F
  #x20 #x2A #x14  ; fg palette 2 (player 2)
  #x0F
  #x20 #x11 #x14  ; fg palette 3 (player 3)
  #x0F
  #x00 #x38 #x14  ; fg palette 4 (player 4)
  )

 ;; animation scripts
 ;; x and y offsets of animation
 ;; #x80 is a sentinel value to end animation
 (deflabel animations)
 (bytes
  ;; bell ding
  #x02 #x00
  #x04 #x00
  #x04 #x00
  #x04 #x00
  #x04 #x00
  #x03 #x00
  #x02 #x00
  #x02 #x00
  #x01 #x00
  #x01 #x00
  #x80)



 (program-complete)
 (asm
".incbin \"handwave.chr\"
; fill the rest of the first chr-rom block with zeroes.
.align $1000"))


